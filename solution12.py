# Name: *** Enter your name here ***
#
# Student-ID: *** Enter your student ID here ***
#
# Rename the file to <yourname>12.py
#
import numpy as np
import matplotlib.pylab as plt
import scipy.signal as signal

def square_wave(x, eps=1e-5):
    dx = (x[1] - x[0]) * eps
    return 0.5 * (signal.square(x + dx) + signal.square(x - dx))

# Please do not change the code above this line

# Exercise 1: Complex  numbers
#
def exercise1():

    plt.close('all')
    
    # Task 1A: Write a local Python function 'phasor' that returns a complex version of
    # an oscillating signal
    # 
    def phasor(t, amplitude=1., frequency=1., phase=0.):
        z0 = amplitude * np.exp(1j * phase)
        return z0 * np.exp(1j * frequency * t)
        
    # Task 1B: Plot the real and imaginary part of the complex version of an
    # oscillating signal (amplitude=2, frequency=2, and a phase=30)
    #
    t = np.linspace(0.0, 2 * np.pi,  100, endpoint=False)
    z = phasor(t, 2.0, 2.0, np.deg2rad(30))
    fig, ax = plt.subplots(figsize=(5, 3))
    ax.plot(t, z.real, label="real")
    ax.plot(t, z.imag, label="imag")
    ax.set_xlabel(r"time $t$")
    ax.legend()
    fig.tight_layout()

    
# Exercise 2: Computing Fourier coefficients by least squares
#
def exercise2():

    plt.close('all')
    
    # Task 2A: Sample the square wave from -pi to pi using 100 sampling points.
    #
    x = np.linspace(-np.pi, np.pi, 100, endpoint=False)
    f = square_wave(x)
        
    # Task 2B: Create the design matrix for N=11
    #
    n = np.arange(12)
    F = np.hstack([np.cos(np.multiply.outer(x, n)),
                   np.sin(np.multiply.outer(x, n[1:]))])
    
    # Task 2C: Compute the Fourier coefficients by evaluating the least squares
    # estimate
    #
    theta2C = np.linalg.pinv(F) @ f
        
    # Task 2D: Evaluate the Fourier coefficients according to equation (2)
    #
    theta2D = np.zeros(23)
    theta2D[12::2] = 4 / (np.pi * n[1::2])

    # Task 2E: Plot both the estimated and the true coefficients for the sine
    # contributions. Also verify that all estimated coefficients of the cosines are
    # close to zero.

    fig, axes = plt.subplots(1, 2, figsize=(7, 3), sharex=True, sharey=True)
    for ax, theta, title in zip(axes, [theta2C, theta2D], ["Least-squares", "Theory"]):
        ax.set_title(title)
        ax.bar(n[1:], theta[12:], color='k', alpha=0.5)
        ax.set_xticks(n[1:])
    axes[0].set_ylabel(r"$b_n$")
    fig.tight_layout()

    print("a_n is zero?", np.allclose(theta2C[:12], 0.0))

    
# Exercise 3: Computing and visualizing the Mandelbrot set
#
def exercise3():

    # close all figures
    plt.close('all')

    # Task 3A: Implement the recurrence relation z = z**2 + c as a local Python called
    # `z_next(z, c)`
    #
    def z_next(z, c):
        """Recurrence relation of the Mandelbrot set."""
        return z**2 + c
    
    # Task 3B: Implement a local Python function called `generate_sequence` that
    # generates the list of the first (n+1) numbers z_n generated by the recurrence
    # relation implemented in `z_next` (Task 3A). 
    #
    def generate_sequence(c, n=100):
        z = [0]
        for _ in range(n):
            z.append(z_next(z[-1], c))
        return z
    
    # Task 3C: Run `generate_sequence` on all `c` in [-0.65, -1.6, -1.75, -1.8, -1.85,
    # 0.25093] with `n=100` and plot the sequences in a single figure
    #
    fig, axes = plt.subplots(2, 3, figsize=(9, 3), sharex=True, sharey=True)
    for ax, c in zip(axes.flat, [-0.65, -1.6, -1.75, -1.8, -1.85, 0.25093]):
        ax.set_title(fr"$c = {c}$")
        ax.plot(generate_sequence(c), color='k', alpha=0.5)
    fig.tight_layout()
    
    # Task 3D: Implement a local Python function `escape_time(c, n_max)` that loops over
    # the recurrence relation `z_next` and breaks out of the loop as soon as |z| > 2.
    # The function should return the iteration number at which |z| exceeded 2 the first
    # time. If this doesn't happen, it will return n_max - 1
    #
    def escape_time(c, n_max=100):
        z = 0
        for n in range(n_max):
            if np.abs(z) > 2: break
            z = z_next(z, c)
        return n
    
    # Task 3E: Evaluate your implementation of `escape_time` on all c values in
    # [4, 2, -1+1j, -1+0.3j, -1+0.29j, -1+0.28j] and print their escape times
    #
    times = list(map(escape_time, [4, 2, -1+1j, -1+0.3j, -1+0.29j, -1+0.28j]))
    print(times)

    # Task 3F: Implement a function `mandelbrot_set(N)` that systematically computes
    # the escape times for all `c` with a real part in [-1.5, 0.5] and imaginary part
    # in [-1, 1] using `N` grid points in each direction. Store the escape times in
    # a (N, N) matrix that is returned by the function. 
    #
    def mandelbrot_set(N):
        """Computes the escape times for all complex numbers `c` whose real part is
        in [-1.5, 0.5] and whose imaginary part is in [-1, 1].

        Example
        -------
        >>> mandelbrot_set(3)
        array([[ 2,  4,  2],
               [99, 99,  5],
               [ 2,  4,  2]])
        
        Parameters
        ----------
        N : int
            Number of grid points used along the real and imaginary part

        Returns
        -------
        (N, N) NumPy array storing the escape times where the row index corresponds to
        the imaginary part of `c` and the column to the real part. 
        """
        times = []
        for y in np.linspace(-1, 1, N):
            for x in np.linspace(-1.5, 0.5, N):
                times.append(escape_time(x + 1j * y))
        return np.reshape(times, (N, N))
    
    # Task 3G: Compute the Mandelbrot set with your implementation of `mandelbrot_set`
    # using [10, 20, 50, 70, 100, 200] grid points along the real and imaginary axis.
    # Plot the matrices returned by `mandelbrot_set` with the `imshow` command.
    #
    fig, axes = plt.subplots(2, 3, figsize=(8, 4))
    for ax, N in zip(axes.flat, [10, 20, 50, 70, 100, 200]):
        ax.set_title(rf"$N={N}$")
        ax.imshow(mandelbrot_set(N), cmap="jet")
        ax.set_axis_off()
    fig.tight_layout()
